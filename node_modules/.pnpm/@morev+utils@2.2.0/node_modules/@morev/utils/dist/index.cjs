"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  arrayInsert: () => arrayInsert,
  arrayInsertMutable: () => arrayInsertMutable,
  arrayOfLength: () => arrayOfLength,
  arrayRange: () => arrayRange,
  arrayRemove: () => arrayRemove,
  arrayRemoveMutable: () => arrayRemoveMutable,
  arraySample: () => arraySample,
  arrayShuffle: () => arrayShuffle,
  arrayUnique: () => arrayUnique,
  arraysDifference: () => arraysDifference,
  arraysIntersection: () => arraysIntersection,
  arraysUnion: () => arraysUnion,
  assert: () => assert,
  camelCase: () => camelCase,
  capitalize: () => capitalize,
  clamp: () => clamp,
  compose: () => compose,
  configureAssert: () => configureAssert,
  createMergeObjects: () => createMergeObjects,
  daysInMonth: () => daysInMonth,
  debounce: () => debounce,
  deepClone: () => deepClone,
  deepCloneStrict: () => deepCloneStrict,
  deepEqual: () => deepEqual,
  deepEqualCircular: () => deepEqualCircular,
  escapeRegExp: () => escapeRegExp,
  fileExtension: () => fileExtension,
  formDataToObject: () => formDataToObject,
  formatBytes: () => formatBytes,
  formatBytesRu: () => formatBytesRu,
  formatSlashes: () => formatSlashes,
  getDocumentSize: () => getDocumentSize,
  getElement: () => getElement,
  getElementOffset: () => getElementOffset,
  getScrollLimit: () => getScrollLimit,
  getScrollableAncestor: () => getScrollableAncestor,
  getScrollbarWidth: () => getScrollbarWidth,
  getWindowScroll: () => getWindowScroll,
  hash: () => hash,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isClient: () => isClient,
  isDate: () => isDate,
  isDev: () => isDev,
  isElement: () => isElement,
  isEmail: () => isEmail,
  isEmpty: () => isEmpty,
  isFirefox: () => isFirefox,
  isFloat: () => isFloat,
  isFormData: () => isFormData,
  isFunction: () => isFunction,
  isInteger: () => isInteger,
  isInternetExplorer: () => isInternetExplorer,
  isIterable: () => isIterable,
  isLighthouse: () => isLighthouse,
  isMap: () => isMap,
  isMobile: () => isMobile,
  isMotionless: () => isMotionless,
  isNode: () => isNode,
  isNullish: () => isNullish,
  isNumeric: () => isNumeric,
  isOSX: () => isOSX,
  isObject: () => isObject,
  isPrimitive: () => isPrimitive,
  isProd: () => isProd,
  isPromise: () => isPromise,
  isRegExp: () => isRegExp,
  isServer: () => isServer,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTest: () => isTest,
  isTouch: () => isTouch,
  isWeakMap: () => isWeakMap,
  kebabCase: () => kebabCase,
  mergeObjects: () => mergeObjects,
  minTimePromise: () => minTimePromise,
  noop: () => noop,
  numberFormat: () => numberFormat,
  objectGet: () => objectGet,
  objectKeysCase: () => objectKeysCase,
  omit: () => omit,
  padEnd: () => padEnd,
  padStart: () => padStart,
  pascalCase: () => pascalCase,
  pick: () => pick,
  promiseController: () => promiseController,
  quote: () => quote,
  randomFloat: () => randomFloat,
  randomInteger: () => randomInteger,
  randomString: () => randomString,
  rangeIncludes: () => rangeIncludes,
  rangesCrop: () => rangesCrop,
  rangesInvert: () => rangesInvert,
  rangesMerge: () => rangesMerge,
  rangesSort: () => rangesSort,
  romanize: () => romanize,
  sleep: () => sleep,
  snakeCase: () => snakeCase,
  supportsPassive: () => supportsPassive,
  throttle: () => throttle,
  toArray: () => toArray,
  toNumber: () => toNumber,
  tsObject: () => tsObject,
  unquote: () => unquote
});
module.exports = __toCommonJS(src_exports);

// src/arrays/array-insert/array-insert.ts
var arrayInsertMutable = (arr, index, ...items) => {
  arr.splice(index, 0, ...items);
  return arr;
};
var arrayInsert = (arr, index, ...items) => arrayInsertMutable([...arr], index, ...items);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-boolean/is-boolean.ts
var isBoolean = (value) => value === true || value === false;

// src/guards/is-date/is-date.ts
var isDate = (value) => Object.prototype.toString.call(value).includes("Date");

// src/guards/is-element/is-element.ts
var isElement = (value) => value?.nodeType === 1;

// src/guards/is-email/is-email.ts
var isEmail = (str) => (
  // eslint-disable-next-line unicorn/no-unsafe-regex
  /^(([^\s"(),.:;<>@[\\\]]+(\.[^\s"(),.:;<>@[\\\]]+)*)|(".+"))@((\[(?:\d{1,3}\.){3}\d{1,3}])|(([\d\-A-Za-zЁА-яё]+\.)+[A-Za-zЁА-яё]{2,}))$/.test(str)
);

// src/guards/is-iterable/is-iterable.ts
var isIterable = (value) => (
  // eslint-disable-next-line unicorn/new-for-builtins
  Symbol.iterator in Object(value)
);

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-empty/is-empty.ts
var isEmpty = (value) => {
  if ([void 0, null, false, NaN, 0, ""].includes(value)) {
    return true;
  }
  if (isIterable(value) && typeof value === "object" && "length" in value && value.length === 0)
    return true;
  if (isIterable(value) && typeof value === "object" && "size" in value && value.size === 0)
    return true;
  if (isObject(value))
    return !Object.keys(value).length;
  return false;
};

// src/guards/is-numeric/is-numeric.ts
var isNumeric = (value) => typeof value === "number" && !isNaN(value);

// src/guards/is-float/is-float.ts
var isFloat = (value) => isNumeric(value) && value % 1 !== 0;

// src/guards/is-form-data/is-form-data.ts
var isFormData = (value) => value instanceof FormData;

// src/guards/is-function/is-function.ts
var isFunction = (value) => Object.prototype.toString.call(value) === "[object Function]";

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => isNumeric(value) && value % 1 === 0;

// src/guards/is-map/is-map.ts
var isMap = (value) => value instanceof Map;

// src/guards/is-node/is-node.ts
var isNode = (value) => value instanceof Node;

// src/guards/is-nullish/is-nullish.ts
var isNullish = (value) => value === null || typeof value === "undefined";

// src/guards/is-primitive/is-primitive.ts
var isPrimitive = (value) => {
  if (isNullish(value))
    return true;
  return !["object", "function"].includes(typeof value);
};

// src/guards/is-promise/is-promise.ts
var isPromise = (value) => value instanceof Promise;

// src/guards/is-reg-exp/is-reg-exp.ts
var isRegExp = (value) => Object.prototype.toString.call(value) === "[object RegExp]";

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-symbol/is-symbol.ts
var isSymbol = (value) => typeof value === "symbol" || typeof value === "object" && Object.prototype.toString.call(value).includes("Symbol");

// src/guards/is-weak-map/is-weak-map.ts
var isWeakMap = (value) => value instanceof WeakMap;

// src/arrays/array-of-length/array-of-length.ts
var arrayOfLength = (length, mapFunction) => {
  const neededLength = isInteger(length) ? length : 0;
  const mapFn = mapFunction ?? (() => void 0);
  return Array.from({ length: neededLength }, (_, index) => mapFn(index));
};

// src/arrays/array-range/array-range.ts
var arrayRange = (from, to) => {
  if (to === void 0) {
    if (from < 0) {
      to = 0;
    } else {
      to = from;
      from = 0;
    }
  }
  return arrayOfLength(Math.abs(to - from) + 1, (index) => index).map((i) => (from > to ? -i : i) + from);
};

// src/arrays/array-remove/array-remove.ts
var arrayRemoveMutable = (arr, value, onlyFirst = false) => {
  while (true) {
    const occurrence = arr.indexOf(value);
    if (occurrence === -1)
      return arr;
    arr.splice(occurrence, 1);
    if (onlyFirst)
      return arr;
  }
};
var arrayRemove = (arr, value, onlyFirst = false) => arrayRemoveMutable([...arr], value, onlyFirst);

// src/numbers/random-integer/random-integer.ts
var randomInteger = (min = 1, max = Number.MAX_SAFE_INTEGER) => Math.floor(Math.random() * (max - min + 1)) + min;

// src/arrays/array-shuffle/array-shuffle.ts
var arrayShuffle = (array) => {
  const copy2 = [...array];
  for (let i = copy2.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [copy2[i], copy2[j]] = [copy2[j], copy2[i]];
  }
  return copy2;
};

// src/arrays/array-sample/array-sample.ts
var arraySample = (array, size = 1, oversize = false) => {
  if (!array?.length || !isInteger(size) || size < 1)
    return void 0;
  if (size === 1) {
    return array[randomInteger(0, array.length - 1)];
  }
  !oversize && (size = Math.min(array.length, size));
  const result = [];
  while (result.length < size) {
    const neededCount = size - result.length;
    const iterationIndexes = arrayOfLength(array.length, (index) => index);
    if (neededCount > array.length) {
      result.push(...iterationIndexes.map((i) => array[i]));
    } else {
      result.push(...arrayShuffle(iterationIndexes).slice(0, neededCount).map((i) => array[i]));
    }
  }
  return result;
};

// src/arrays/array-unique/array-unique.ts
var arrayUnique = (array) => [...new Set(array)];

// src/arrays/arrays-intersection/arrays-intersection.ts
var arraysIntersection = (...arrays) => arrays.reduce((acc, array) => acc.filter((i) => array.includes(i)));

// src/arrays/arrays-union/arrays-union.ts
var arraysUnion = (...arrays) => [...new Set(arrays.flat())];

// src/arrays/arrays-difference/arrays-difference.ts
var arraysDifference = (...arrays) => {
  const intersections = arraysIntersection(...arrays);
  return arraysUnion(...arrays.map((array) => array.filter((i) => !intersections.includes(i))));
};

// src/arrays/to-array/to-array.ts
var toArray = (value) => [value].flat();

// src/dates/days-in-month/days-in-month.ts
var daysInMonth = (monthIndex, year) => {
  year ??= (/* @__PURE__ */ new Date()).getFullYear();
  return new Date(year, monthIndex + 1, 0).getDate();
};

// src/dom/get-document-size/get-document-size.ts
var getDocumentSize = (axis = "y") => {
  const scrollWidth = Math.max(
    document.body.scrollWidth,
    document.documentElement.scrollWidth,
    document.body.offsetWidth,
    document.documentElement.offsetWidth,
    document.body.clientWidth,
    document.documentElement.clientWidth
  );
  const scrollHeight = Math.max(
    document.body.scrollHeight,
    document.documentElement.scrollHeight,
    document.body.offsetHeight,
    document.documentElement.offsetHeight,
    document.body.clientHeight,
    document.documentElement.clientHeight
  );
  return axis === "both" ? { x: scrollWidth, y: scrollHeight } : axis === "x" ? scrollWidth : scrollHeight;
};

// src/dom/get-element/get-element.ts
var getElement = (value, parent = null) => {
  if (isString(parent)) {
    parent = document.querySelector(parent);
  }
  if (isString(value)) {
    return isElement(parent) ? parent.querySelector(value) : document.querySelector(value);
  }
  if (isElement(value)) {
    return isElement(parent) ? parent.contains(value) ? value : null : value;
  }
  return null;
};

// src/dom/get-window-scroll/get-window-scroll.ts
var getScrollTop = () => Math.max(window.pageYOffset || 0, window.scrollY || 0, document.documentElement.scrollTop, document.body.scrollTop);
var getScrollLeft = () => Math.max(window.pageXOffset || 0, window.scrollX || 0, document.documentElement.scrollLeft, document.body.scrollLeft);
var getWindowScroll = (axis = "y") => {
  if (axis === "y")
    return getScrollTop();
  if (axis === "x")
    return getScrollLeft();
  return { x: getScrollLeft(), y: getScrollTop() };
};

// src/dom/get-element-offset/get-element-offset.ts
var getElementScroll = (el, axis = "both") => {
  if (axis === "both") {
    return { x: el.scrollLeft, y: el.scrollTop };
  }
  return axis === "x" ? el.scrollLeft : el.scrollTop;
};
var getElementOffset = (el, axis = "both", parent = window) => {
  const parentRect = parent === window ? { top: 0, left: 0 } : parent.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  const top = elRect.top - parentRect.top;
  const left = elRect.left - parentRect.left;
  const scroll = parent === window ? getWindowScroll(axis) : getElementScroll(parent, axis);
  if (axis === "y")
    return top + scroll;
  if (axis === "x")
    return left + scroll;
  return {
    // @ts-expect-error -- TODO
    x: left + scroll.x,
    // @ts-expect-error -- TODO
    y: top + scroll.y
  };
};

// src/dom/get-scroll-limit/get-scroll-limit.ts
var toMax = (v) => Math.max(0, v);
var getScrollLimit = (axis = "y") => {
  if (axis === "both") {
    const ds2 = getDocumentSize(axis);
    return {
      x: toMax(ds2.x - window.innerWidth),
      y: toMax(ds2.y - window.innerHeight)
    };
  }
  const ds = getDocumentSize(axis);
  return axis === "x" ? toMax(ds - window.innerWidth) : toMax(ds - window.innerHeight);
};

// src/dom/get-scrollable-ancestor/get-scrollable-ancestor.ts
var getScrollableAncestor = (element, axis = "both") => {
  let el = element;
  while (el?.parentElement) {
    el = el.parentElement;
    if (el === document.body)
      return window;
    if (el === document.documentElement)
      return window;
    const styles = window.getComputedStyle(el);
    const toCheck = [];
    ["both", "x"].includes(axis) && toCheck.push(styles.getPropertyValue("overflow-x"));
    ["both", "y"].includes(axis) && toCheck.push(styles.getPropertyValue("overflow-y"));
    const isScrollable = toCheck.some((val) => ["auto", "scroll"].includes(val));
    if (isScrollable)
      return el;
  }
  return window;
};

// src/dom/get-scrollbar-width/get-scrollbar-width.ts
var getScrollbarWidth = (el = document.body) => {
  return el === document.body ? window.innerWidth - document.documentElement.clientWidth : el.offsetWidth - el.clientWidth;
};

// src/environment/is-client/is-client.ts
var isClient = () => typeof window !== "undefined";

// src/environment/is-dev/is-dev.ts
var isDev = () => {
  if (typeof process === "undefined")
    return null;
  return process.env.NODE_ENV === "development";
};

// src/environment/is-firefox/is-firefox.ts
var isFirefox = () => !!navigator.userAgent.toLowerCase().match(/firefox./);

// src/environment/is-internet-explorer/is-internet-explorer.ts
var isInternetExplorer = () => !!navigator.userAgent.toLowerCase().match(/trident./);

// src/environment/is-lighthouse/is-lighthouse.ts
var isLighthouse = (userAgent) => {
  if (!userAgent && isClient()) {
    userAgent = window.navigator.userAgent;
  }
  return ["Lighthouse", "Page Speed", "PageSpeed"].some((part) => (userAgent ?? "").includes(part));
};

// src/environment/is-mobile/is-mobile.ts
var isMobile = () => /android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i.test(navigator.userAgent);

// src/environment/is-motionless/is-motionless.ts
var isMotionless = () => window.matchMedia("(prefers-reduced-motion: reduce)").matches;

// src/environment/is-osx/is-osx.ts
var isOSX = () => {
  const platform = navigator.userAgentData?.platform || navigator.platform || "";
  return !!platform.match(/(ipad|iphone|ipod|mac)/i);
};

// src/environment/is-prod/is-prod.ts
var isProd = () => {
  if (typeof process === "undefined")
    return null;
  return process.env.NODE_ENV === "production";
};

// src/environment/is-server/is-server.ts
var isServer = () => typeof window === "undefined";

// src/environment/is-test/is-test.ts
var isTest = () => process.env.NODE_ENV === "test";

// src/environment/is-touch/is-touch.ts
var isTouch = () => "ontouchstart" in window || !!navigator?.msMaxTouchPoints;

// src/environment/supports-passive/supports-passive.ts
var supportsPassive = () => {
  let supports = false;
  const options = Object.defineProperty({}, "passive", {
    get() {
      supports = true;
      return null;
    }
  });
  try {
    const noop2 = () => {
    };
    window.addEventListener("test:passive", noop2, options);
    window.removeEventListener("test:passive", noop2, options);
  } catch {
  }
  return supports;
};

// src/functions/assert/assert.utils.ts
var typeMap = {
  "condition": "Assert condition failed",
  "no-value": "Assert value not undefined/null failed"
};
var messageFormatter = (failureType, message, properties) => {
  return [
    typeMap[failureType],
    message ? `: ${message}` : null,
    !isEmpty(properties) ? `: ${JSON.stringify(properties)}` : null
  ].filter(Boolean).join("");
};
var errorCreatorFactory = (formatter) => (failureType, message, properties) => new Error(formatter(failureType, message, properties));
var createConfiguration = () => ({
  formatter: messageFormatter,
  errorCreator: errorCreatorFactory(messageFormatter)
});

// src/functions/assert/assert.ts
var configuration = createConfiguration();
var _createAssert = (soft) => (conditionOrValue, message, properties) => {
  const createError = (type, props2) => configuration.errorCreator(type, message, props2);
  const report = (type, props2, error) => {
    error && configuration.errorReporter?.(type, error, message, props2);
    !error && configuration.warningReporter?.(type, message, props2);
  };
  const props = isFunction(properties) ? properties() : properties ?? {};
  if (isBoolean(conditionOrValue) && !conditionOrValue) {
    if (!soft) {
      const error = createError("condition", props);
      report("condition", props, error);
      throw error;
    }
    report("condition", props);
    return false;
  }
  if (isNullish(conditionOrValue)) {
    if (!soft) {
      const error = createError("no-value", props);
      report("no-value", props, error);
      throw error;
    }
    report("no-value", props);
    return false;
  }
  return conditionOrValue;
};
var hardAssert = _createAssert(false);
var softAssert = _createAssert(true);
var _assert = hardAssert;
_assert.soft = softAssert;
var assert = _assert;
var configureAssert = (customConfiguration) => {
  configuration = {
    ...configuration,
    ...customConfiguration,
    errorCreator: customConfiguration.errorCreator ?? errorCreatorFactory(customConfiguration.formatter ?? messageFormatter)
  };
};

// src/functions/compose/compose.ts
var compose = (...functions) => (value) => [...functions].reverse().reduce((acc, curr) => acc = curr(acc), value);

// src/functions/debounce/debounce.ts
var debounce = (fn, delay = 60, immediate = false) => {
  let timer;
  let started = false;
  const debounced = function(...args) {
    if (!started) {
      if (immediate)
        fn.apply(this, args);
      started = true;
    }
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
      started = false;
    }, delay);
  };
  return debounced;
};

// src/functions/hash/hash.ts
var import_ohash = require("ohash");
var hash = (value, options) => (0, import_ohash.hash)(value, options);

// src/functions/noop/noop.ts
var noop = () => {
};

// src/functions/sleep/sleep.ts
var sleep = async (duration = 0) => new Promise((resolve) => setTimeout(resolve, duration));

// src/functions/throttle/throttle.ts
var parseOptions = (optionsOrDelay) => {
  if (isObject(optionsOrDelay)) {
    return [
      optionsOrDelay.delay ?? 0,
      optionsOrDelay.leading ?? true,
      optionsOrDelay.trailing ?? true
    ];
  }
  return [optionsOrDelay ?? 0, true, true];
};
var throttle = (callback, optionsOrDelay) => {
  const [delay, leading, trailing] = parseOptions(optionsOrDelay);
  let timeoutID = null;
  let cancelled;
  let lastExec = leading ? 0 : Date.now();
  const clearExistingTimeout = () => {
    if (!timeoutID)
      return;
    clearTimeout(timeoutID);
    timeoutID = null;
  };
  const cancel = () => {
    clearExistingTimeout();
    cancelled = true;
  };
  const trailingExec = (exec) => {
    if (!trailing)
      return;
    clearExistingTimeout();
    timeoutID ||= setTimeout(exec, delay);
  };
  function wrapper(...args) {
    if (cancelled)
      return;
    const self = this;
    const exec = () => {
      lastExec = Date.now();
      callback.apply(self, args);
    };
    trailingExec(exec);
    const runTime = Date.now() - lastExec;
    if (runTime > delay)
      exec();
  }
  wrapper.cancel = cancel;
  return wrapper;
};

// src/numbers/clamp/clamp.ts
var clamp = (value, min = -Infinity, max = Infinity) => Math.max(
  min ?? -Infinity,
  Math.min(value, max ?? Infinity)
);

// src/objects/deep-clone/deep-clone.ts
var import_fast_copy = require("fast-copy");
var copy = (0, import_fast_copy.createCopier)({});
var deepClone = (value) => copy(value);
var deepCloneStrict = (value) => (0, import_fast_copy.copyStrict)(value);

// src/objects/deep-equal/deep-equal.ts
var import_fast_equals = require("fast-equals");
var deepEqual = (a, b) => (0, import_fast_equals.deepEqual)(a, b);
var deepEqualCircular = (a, b) => (0, import_fast_equals.circularDeepEqual)(a, b);

// src/objects/form-data-to-object/form-data-to-object.ts
var formDataToObject = (formData) => {
  const result = {};
  for (const [key, value] of formData.entries()) {
    result[key] = key in result ? [...toArray(result[key]), value] : value;
  }
  return result;
};

// src/objects/merge-objects/merge-objects.ts
var _mergeObjects = (defaults, input, stack = "", merger) => {
  const result = { ...defaults };
  if (!isObject(input))
    return result;
  Object.entries(input).forEach(([key, val]) => {
    if (merger?.(result, key, val, stack))
      return;
    if (isObject(val) && isObject(result[key])) {
      Object.assign(result, { [key]: _mergeObjects(result[key], val, (stack ? `${stack}.` : "") + key, merger) });
    } else {
      Object.assign(result, { [key]: val });
    }
  });
  return result;
};
var createMergeObjects = (merger) => (...args) => args.reduce((p, c) => _mergeObjects(p, c, "", merger), {});
var mergeObjects = createMergeObjects();

// src/numbers/to-number/to-number.ts
function toNumber(value, fallback) {
  const throwOrReturnFallback = () => {
    if (arguments.length === 1) {
      throw new Error(`The value "${value}" cannot be converted to a number`);
    }
    return fallback;
  };
  if (isNumeric(value))
    return value;
  if (isString(value)) {
    const number = Number(value);
    return isNumeric(number) ? number : throwOrReturnFallback();
  }
  return throwOrReturnFallback();
}

// src/objects/object-get/object-get.ts
var extractSegments = (path) => toArray(path).map((p) => p.toString().trim()).flatMap((part) => part.replaceAll(/\[(.?)]/g, ".$1.").replaceAll(/\.+/g, ".").split(".").filter(Boolean).map((p) => toNumber(p, p)));
var objectGet = (input, path, defaultValue = void 0) => {
  if (!input || !isObject(input) && !isArray(input) || isNullish(path)) {
    return defaultValue;
  }
  const segments = extractSegments(path);
  let result = input;
  while (segments.length) {
    const property = segments.shift();
    if (!(property in result))
      return defaultValue;
    result = result[property];
  }
  return result;
};

// src/strings/camel-case/camel-case.ts
var UPPERCASE = /\p{Lu}/u;
var LOWERCASE = /\p{Ll}/u;
var LEADING_CAPITAL = /^\p{Lu}(?!\p{Lu})/gu;
var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
var SEPARATORS = /[ \-._]+/;
var LEADING_SEPARATORS = new RegExp(`^${SEPARATORS.source}`);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
var NUMBERS_AND_IDENTIFIER = new RegExp(`\\d+${IDENTIFIER.source}`, "gu");
var defaultOptions = {
  preserveConsecutiveUppercase: false
};
var preserveCamelCase = (string) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  for (let i = 0; i < string.length; i++) {
    const character = string[i];
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = `${string.slice(0, i)}-${string.slice(i)}`;
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
      string = `${string.slice(0, i - 1)}-${string.slice(i - 1)}`;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = (input) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replace(LEADING_CAPITAL, (m1) => m1.toLowerCase());
};
var postProcess = (input) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => identifier.toUpperCase()).replace(NUMBERS_AND_IDENTIFIER, (m) => m.toUpperCase());
};
var camelCase = (input, options) => {
  if (!isArray(!input) && !isString(input)) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = { ...defaultOptions, ...options };
  input = isArray(input) ? input.map((v) => v.trim()).filter(Boolean).join("-") : input.trim();
  if (!input.length)
    return "";
  if (input.length === 1)
    return input.toLowerCase();
  if (input !== input.toLowerCase()) {
    input = preserveCamelCase(input);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input) : input.toLowerCase();
  return postProcess(input);
};

// src/strings/capitalize/capitalize.ts
var capitalize = (input) => {
  if (!input.length)
    return "";
  return input[0].toUpperCase() + input.slice(1);
};

// src/strings/escape-reg-exp/escape-reg-exp.ts
var escapeRegExp = (str) => (str ?? "").replace(/[$()*+.?[\\\]^{|}]/g, "\\$&");

// src/strings/file-extension/file-extension.ts
var fileExtension = (input) => {
  const basePath = input.split(/[/\\]/).pop();
  return basePath.slice((Math.max(0, basePath.lastIndexOf(".")) || Infinity) + 1) || null;
};

// src/strings/format-slashes/format-slashes.ts
var formatSlashes = (input, options) => {
  input = input.replace(/([^:]\/)\/+/g, "$1").replace(/\\{2,}/g, "\\");
  if (options?.to) {
    const re = options.to === "/" ? "\\\\" : "/";
    input = input.replace(new RegExp(re, "g"), options.to);
  }
  const slash = options?.to ?? input.match(/[/\\]/)?.[0] ?? "/";
  if (options?.start === true && !input.startsWith(slash)) {
    input = slash + input;
  }
  if (options?.start === false && input.startsWith(slash)) {
    input = input.slice(1);
  }
  if (options?.end === true && !input.endsWith(slash)) {
    input += slash;
  }
  if (options?.end === false && input.endsWith(slash)) {
    input = input.slice(0, -1);
  }
  return input;
};

// src/strings/kebab-case/kebab-case.ts
var kebabCase = (input, _options2) => {
  const options = { numbers: false, ..._options2 };
  let result = input.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s._]+/g, "-");
  if (!options.numbers)
    return result.toLowerCase();
  result = result.replace(/\d+/, "-$&").replace(/(\d)([A-Z])/g, "$1-$2");
  return result.startsWith("-") ? result.slice(1).toLowerCase() : result.toLowerCase();
};

// src/strings/pad-end/pad-end.ts
var padEnd = (input, maxLength, fillString = " ") => input.toString().padEnd(maxLength, fillString);

// src/strings/pad-start/pad-start.ts
var padStart = (input, maxLength = 2, fillString = "0") => input.toString().padStart(maxLength, fillString);

// src/strings/pascal-case/pascal-case.ts
var defaultOptions2 = {
  preserveConsecutiveUppercase: false
};
var pascalCase = (input, options) => {
  const base = camelCase(input, { ...defaultOptions2, ...options });
  if (!base.length)
    return "";
  return base[0].toUpperCase() + base.slice(1);
};

// src/strings/quote/quote.ts
var quote = (str, char = '"') => {
  if (str === "")
    return `${char}${char}`;
  const [first, last] = [str[0], str[str.length - 1]];
  if (first !== char)
    str = char + str;
  if (last !== char)
    str += char;
  return str;
};

// src/strings/random-string/random-string.ts
var randomString = (length = 10, startWithLatin = true) => {
  const base = arrayOfLength(length, () => Math.trunc(Math.random() * 36).toString(36)).join("");
  if (!startWithLatin)
    return base;
  const latinCharacters = "abcdefghijklmnopqrstuvwxyz";
  const firstChar = latinCharacters.charAt(Math.floor(Math.random() * latinCharacters.length));
  return firstChar + base.slice(1);
};

// src/strings/romanize/romanize.ts
var numerals = {
  M: 1e3,
  CM: 900,
  D: 500,
  CD: 400,
  C: 100,
  XC: 90,
  L: 50,
  XL: 40,
  X: 10,
  IX: 9,
  V: 5,
  IV: 4,
  I: 1
};
var romanize = (num) => Object.entries(numerals).reduce((acc, [key, value]) => {
  acc += key.repeat(num / value >>> 0);
  num %= value;
  return acc;
}, "");

// src/strings/snake-case/snake-case.ts
var snakeCase = (input) => input.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s\-.]+/g, "_").toLowerCase();

// src/strings/unquote/unquote.ts
var unquote = (str) => {
  if (!str)
    return "";
  const [first, last] = [str[0], str[str.length - 1]];
  if (first !== last)
    return str;
  if (first === '"' || first === "'" || first === "`")
    return str.slice(1, -1);
  return str;
};

// src/objects/object-keys-case/object-keys-case.ts
var getPath = (path, ...parts) => path ? `${path}.${parts.join(".")}` : parts.join(".");
var getHandler = (neededCase) => {
  switch (neededCase) {
    case "snake_case":
      return snakeCase;
    case "PascalCase":
      return pascalCase;
    case "camelCase":
      return camelCase;
    case "kebab-case":
      return kebabCase;
    default:
      return (v) => v;
  }
};
var objectKeysCase = (input, neededCase, _options2) => {
  const options = mergeObjects({
    depth: Infinity,
    exclude: [],
    excludeBranches: []
  }, _options2);
  const handler = getHandler(neededCase);
  const isExcluded = (type, key) => {
    const entity = type === "key" ? options.exclude : options.excludeBranches;
    return entity.some((item) => {
      if (isString(item))
        return item === key;
      if (isRegExp(item))
        return item.test(key);
      return false;
    });
  };
  const isDepthAllowed = (depth) => options.depth > depth;
  const processEntry = (entry, path, depth) => {
    if (!isObject(entry) && !isArray(entry))
      return entry;
    const isEntryArray = isArray(entry);
    return Object.entries(entry).reduce((acc, [_key, _value]) => {
      const shouldTransformKey = !isExcluded("key", _key) && !isExcluded("branch", getPath(path, _key)) && isDepthAllowed(depth);
      const shouldTransformValue = !isExcluded("branch", getPath(path, _key)) && isDepthAllowed(depth + 1);
      const key = shouldTransformKey ? handler(_key) : _key;
      const value = shouldTransformValue ? processEntry(_value, getPath(path, _key), depth + 1) : _value;
      if (isEntryArray)
        acc.push(value);
      if (!isEntryArray)
        acc[key] = value;
      return acc;
    }, isEntryArray ? [] : {});
  };
  return processEntry(input, "", 0);
};

// src/objects/omit/omit.ts
var omit = (obj, ...keys) => Object.fromEntries(Object.entries(obj ?? {}).filter(([k]) => !keys.includes(k)));

// src/objects/pick/pick.ts
var pick = (obj, ...keys) => Object.fromEntries(
  keys.filter((key) => key in obj).map((key) => [key, obj[key]])
);

// src/objects/ts-object/ts-object.ts
var tsObject = {
  /**
   * Typed version of `Object.keys()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.keys()` return value for a given object.
   */
  keys: (obj) => Object.keys(obj),
  /**
   * Typed version of `Object.values()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.values()` return value for a given object.
   */
  values: (obj) => Object.values(obj),
  /**
   * Typed version of `Object.entries()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.entries()` return value for a given object.
   */
  entries: (obj) => Object.entries(obj),
  /**
   * Typed version of `Object.fromEntries()`.
   *
   * @param   entries   Entries to process.
   *
   * @returns           `Object.fromEntries()` return value for a given object.
   */
  fromEntries: (entries) => Object.fromEntries(entries)
};

// src/numbers/format-bytes/format-bytes.ts
var REFERENCE_TABLE = {
  metric: [
    { from: 0, to: 1e3, prefix: "b" },
    { from: 1e3, to: 1e6, prefix: "k" },
    { from: 1e6, to: 1e9, prefix: "m" },
    { from: 1e9, to: 1e12, prefix: "g" },
    { from: 1e12, to: 1e15, prefix: "t" },
    { from: 1e15, to: 1e18, prefix: "p" },
    { from: 1e18, to: 1e21, prefix: "e" },
    { from: 1e21, to: 1e24, prefix: "z" },
    { from: 1e24, to: 1e27, prefix: "y" }
  ],
  IEC: [
    { from: 0, to: 1024 ** 1, prefix: "b" },
    { from: 1024 ** 1, to: 1024 ** 2, prefix: "k" },
    { from: 1024 ** 2, to: 1024 ** 3, prefix: "m" },
    { from: 1024 ** 3, to: 1024 ** 4, prefix: "g" },
    { from: 1024 ** 4, to: 1024 ** 5, prefix: "t" },
    { from: 1024 ** 5, to: 1024 ** 6, prefix: "p" },
    { from: 1024 ** 6, to: 1024 ** 7, prefix: "e" },
    { from: 1024 ** 7, to: 1024 ** 8, prefix: "z" },
    { from: 1024 ** 8, to: 1024 ** 9, prefix: "y" }
  ]
};
var UNITS_DEFAULTS = {
  metric: {
    b: "B",
    k: "kB",
    m: "MB",
    g: "GB",
    t: "TB",
    p: "PB",
    e: "EB",
    z: "ZB",
    y: "YB"
  },
  IEC: {
    b: "B",
    k: "KiB",
    m: "MiB",
    g: "GiB",
    t: "TiB",
    p: "PiB",
    e: "EiB",
    z: "ZiB",
    y: "YiB"
  }
};
var DEFAULT_OPTIONS = {
  precision: 1,
  to: "auto",
  trimZeros: true,
  mode: "metric",
  toString: (value, valueAsString, unit, isInteger2) => `${valueAsString} ${unit}`
};
var _options = /* @__PURE__ */ new WeakMap();
var FormatBytes = class {
  /**
   * The calculated value.
   */
  value;
  /**
   * The calculated value in string form with needed precision.
   */
  valueAsString;
  /**
   * Calculated unit of value.
   */
  unit;
  /**
   * Whether the value is an integer number. \
   * Mostly used for `i18n` purposes.
   */
  isInteger;
  constructor(bytes, customOptions) {
    if (!isInteger(bytes))
      bytes = 0;
    const options = mergeObjects(DEFAULT_OPTIONS, customOptions);
    _options.set(this, options);
    const referenceTable = REFERENCE_TABLE[options.mode];
    const entry = options.to === "auto" ? referenceTable.find((e) => bytes >= e.from && bytes < e.to) ?? referenceTable[0] : referenceTable.find((i) => i.prefix === options.to) ?? referenceTable[0];
    const { from, prefix } = entry;
    const unitsReferenceTable = mergeObjects(UNITS_DEFAULTS, options.customUnits);
    const unit = unitsReferenceTable[options.mode][prefix];
    let value = bytes / from;
    value = Number.isFinite(value) ? value : bytes;
    let valueAsString = value.toFixed(options.precision);
    value = parseFloat(valueAsString);
    if (options.trimZeros) {
      value = parseFloat(valueAsString);
      valueAsString = value.toString();
    }
    const isInteger2 = isInteger(value);
    this.value = value;
    this.valueAsString = valueAsString;
    this.unit = unit;
    this.isInteger = isInteger2;
  }
  toString() {
    const { value, valueAsString, unit, isInteger: isInteger2 } = this;
    const options = _options.get(this);
    return options.toString(value, valueAsString, unit, isInteger2);
  }
};
var formatBytes = (bytes, customOptions) => new FormatBytes(bytes, customOptions);
var formatBytesRu = (bytes, _customOptions) => {
  const customOptions = mergeObjects({
    // Not sure actually, it's not reglamented ¯\_(ツ)_/¯
    customUnits: {
      metric: {
        b: "\u0411",
        k: "\u041A\u0411",
        m: "\u041C\u0411",
        g: "\u0413\u0411",
        t: "\u0422\u0411",
        p: "\u041F\u0411",
        e: "\u0415\u0411",
        z: "\u0417\u0411",
        y: "\u0418\u0411"
      },
      IEC: {
        b: "\u0411",
        k: "\u041A\u0431",
        m: "\u041C\u0431",
        g: "\u0413\u0431",
        t: "\u0422\u0431",
        p: "\u041F\u0431",
        e: "\u0415\u0431",
        z: "\u0417\u0431",
        y: "\u0418\u0431"
      }
    }
  }, _customOptions);
  return new FormatBytes(bytes, customOptions);
};

// src/numbers/number-format/number-format.ts
var numberFormat = (numberOrStringRepresentingNumber, decimals = 0, fractionSeparator = ".", thousandsSeparator = "\xA0") => {
  const number = toNumber(numberOrStringRepresentingNumber, 0);
  const toFixedFix = () => {
    const k = 10 ** decimals;
    return Math.round(number * k) / k;
  };
  const parts = String(decimals ? toFixedFix() : Math.round(number)).split(".");
  let [int, fraction = ""] = parts;
  if (int.length > 3) {
    int = int.replace(/\B(?=(?:\d{3})+(?!\d))/g, thousandsSeparator);
  }
  if (fraction.length < decimals) {
    fraction += arrayOfLength(decimals - fraction.length + 1).join("0");
  }
  return [int, fraction].filter(Boolean).join(fractionSeparator);
};

// src/numbers/random-float/random-float.ts
var randomFloat = (min, max, precision = 1) => parseFloat((Math.random() * (max - min) + min).toFixed(precision));

// src/promises/min-time-promise/min-time-promise.ts
var minTimePromise = async (promise, minTime = 0) => {
  const startTime = Date.now();
  let errorTime = null;
  const result = await Promise.all([promise, sleep(minTime)]).catch((e) => {
    errorTime = Date.now();
    return [e];
  });
  if (errorTime) {
    await sleep(clamp(minTime - (errorTime - startTime), 0));
    throw result[0];
  }
  return result[0];
};

// src/promises/promise-controller/promise-controller.ts
var promiseController = () => {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
};

// src/ranges/range-includes/range-includes.ts
var rangeIncludes = (value, ranges, mode = "any") => {
  const method = mode === "all" ? "every" : "some";
  return (ranges ?? [])[method](([min, max]) => {
    if (!isNullish(min) && value < min)
      return false;
    if (!isNullish(max) && value > max)
      return false;
    return true;
  });
};

// src/ranges/ranges-sort/ranges-sort.ts
var comparator = (a, b) => {
  if (isNullish(a) && isNullish(b))
    return 0;
  if (isNullish(a) && !isNullish(b))
    return -1;
  if (!isNullish(a) && isNullish(b))
    return 1;
  assert(isNumeric(a) && isNumeric(b));
  if (a < b)
    return -1;
  if (a > b)
    return 1;
  return 0;
};
var rangesSort = (ranges) => {
  return [...ranges ?? []].filter((r) => !isNullish(r)).sort((r1, r2) => {
    assert(!isNullish(r1) && !isNullish(r2));
    if (r1[0] === r2[0]) {
      return comparator(r1[1], r2[1]);
    }
    return comparator(r1[0], r2[0]);
  });
};

// src/ranges/ranges-merge/ranges-merge.ts
var rangesMerge = (ranges, joinEdges = true) => {
  const sorted = rangesSort(ranges).map((r) => [
    isNullish(r[0]) ? -Infinity : r[0],
    isNullish(r[1]) ? Infinity : r[1]
  ]);
  for (let l = sorted.length - 1, i = l; i > 0; i--) {
    if (sorted[i][0] <= sorted[i - 1][0] || !joinEdges && sorted[i][0] < sorted[i - 1][1] || joinEdges && sorted[i][0] <= sorted[i - 1][1]) {
      sorted[i - 1][0] = Math.min(sorted[i][0], sorted[i - 1][0]);
      sorted[i - 1][1] = Math.max(sorted[i][1], sorted[i - 1][1]);
      sorted.splice(i, 1);
      i = sorted.length;
    }
  }
  return sorted.length ? sorted.map((r) => [
    r[0] === -Infinity ? null : r[0],
    r[1] === Infinity ? null : r[1]
  ]) : [];
};

// src/ranges/utils.ts
var formatInfinity = (value, isNeeded) => isNeeded ? value === Infinity || value === -Infinity ? null : value : value;

// src/ranges/ranges-crop/ranges-crop.ts
var rangesCrop = (ranges, start = null, end = null, infinityToNull = false) => {
  if (isEmpty(ranges))
    return [];
  if (isNullish(start))
    start = -Infinity;
  if (isNullish(end))
    end = Infinity;
  return rangesMerge(ranges).map((range) => [
    isNullish(range[0]) ? -Infinity : range[0],
    isNullish(range[1]) ? Infinity : range[1]
  ]).filter((range) => range[1] >= start && range[0] <= end).map((range) => {
    let [first, second] = range;
    if (first < start)
      first = start;
    if (second > end)
      second = end;
    return [
      formatInfinity(first, infinityToNull),
      formatInfinity(second, infinityToNull)
    ];
  });
};

// src/ranges/ranges-invert/ranges-invert.ts
var rangesInvert = (ranges, start = null, end = null, infinityToNull = false) => {
  if (isNullish(start))
    start = -Infinity;
  if (isNullish(end))
    end = Infinity;
  return rangesCrop(
    rangesMerge(ranges).reduce((acc, range, i, arr) => {
      const res = [];
      if (i === 0 && arr[0][0] > start) {
        res.push([
          formatInfinity(start, infinityToNull),
          formatInfinity(arr[0][0], infinityToNull)
        ]);
      }
      const tail = i < arr.length - 1 ? arr[i + 1][0] : end;
      if (!rangeIncludes(end, [range])) {
        res.push([
          formatInfinity((range[1] ?? -Infinity) > start ? range[1] : start, infinityToNull),
          formatInfinity(tail, infinityToNull)
        ]);
      }
      return res.length ? [...acc, ...res] : acc;
    }, []),
    start,
    end,
    infinityToNull
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  arrayInsert,
  arrayInsertMutable,
  arrayOfLength,
  arrayRange,
  arrayRemove,
  arrayRemoveMutable,
  arraySample,
  arrayShuffle,
  arrayUnique,
  arraysDifference,
  arraysIntersection,
  arraysUnion,
  assert,
  camelCase,
  capitalize,
  clamp,
  compose,
  configureAssert,
  createMergeObjects,
  daysInMonth,
  debounce,
  deepClone,
  deepCloneStrict,
  deepEqual,
  deepEqualCircular,
  escapeRegExp,
  fileExtension,
  formDataToObject,
  formatBytes,
  formatBytesRu,
  formatSlashes,
  getDocumentSize,
  getElement,
  getElementOffset,
  getScrollLimit,
  getScrollableAncestor,
  getScrollbarWidth,
  getWindowScroll,
  hash,
  isArray,
  isBoolean,
  isClient,
  isDate,
  isDev,
  isElement,
  isEmail,
  isEmpty,
  isFirefox,
  isFloat,
  isFormData,
  isFunction,
  isInteger,
  isInternetExplorer,
  isIterable,
  isLighthouse,
  isMap,
  isMobile,
  isMotionless,
  isNode,
  isNullish,
  isNumeric,
  isOSX,
  isObject,
  isPrimitive,
  isProd,
  isPromise,
  isRegExp,
  isServer,
  isString,
  isSymbol,
  isTest,
  isTouch,
  isWeakMap,
  kebabCase,
  mergeObjects,
  minTimePromise,
  noop,
  numberFormat,
  objectGet,
  objectKeysCase,
  omit,
  padEnd,
  padStart,
  pascalCase,
  pick,
  promiseController,
  quote,
  randomFloat,
  randomInteger,
  randomString,
  rangeIncludes,
  rangesCrop,
  rangesInvert,
  rangesMerge,
  rangesSort,
  romanize,
  sleep,
  snakeCase,
  supportsPassive,
  throttle,
  toArray,
  toNumber,
  tsObject,
  unquote
});

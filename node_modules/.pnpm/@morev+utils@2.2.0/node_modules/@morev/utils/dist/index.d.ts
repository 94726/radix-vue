import { Primitive, JsonObject } from 'type-fest';
export { Includes as ArrayIncludes, AsyncReturnType, Asyncify, Promisable as Awaitable, CamelCase, CamelCasedProperties, CamelCasedPropertiesDeep, Class, Constructor, IterableElement as ElementOf, EmptyObject, Entries, Entry, Exact, Except, Simplify as Explicit, Finite, Float, Get, GlobalThis, HasOptionalKeys, HasRequiredKeys, IfAny, IfNever, IfUnknown, Integer, InvariantOf, IsAny, IsBooleanLiteral, IsEmptyObject, IsEqual, IsLiteral, IsNever, IsNumericLiteral, IsStringLiteral, IsSymbolLiteral, IsUnknown, Join, JsonArray, JsonObject, JsonPrimitive, JsonValue, Jsonifiable, Jsonify, KebabCase, KebabCasedProperties, KebabCasedPropertiesDeep, LastArrayElement, LiteralToPrimitive, LiteralToPrimitiveDeep, LiteralUnion, Merge, MergeDeep, MergeExclusive, MultidimensionalArray, MultidimensionalReadonlyArray, Negative, NegativeFloat, NegativeInfinity, NegativeInteger, NonNegative, NonNegativeInteger, OmitIndexSignature, Opaque, OptionalKeysOf, OverrideProperties, PackageJson, PartialDeep, SetNonNullable as PartialNonNullable, PartialOnUndefinedDeep, SetOptional as PartialOptional, SetRequired as PartialRequired, SetReturnType as PartialReturnType, PascalCase, PascalCasedProperties, PascalCasedPropertiesDeep, PickIndexSignature, PositiveInfinity, Primitive, ReadonlyDeep, ReadonlyKeysOf, ReadonlyTuple, RequiredDeep, RequiredKeysOf, Schema, SnakeCase, SnakeCasedProperties, SnakeCasedPropertiesDeep, Split, Spread, StringKeyOf, Replace as StringReplace, Stringified, TaggedUnion, Trim, TsConfigJson as TsConfig, TupleToUnion, TypedArray, UnionToIntersection, UnwrapOpaque, ScreamingSnakeCase as UpperSnakeCase, ValueOf, Writable, WritableDeep, WritableKeysOf } from 'type-fest';
import { hash as hash$1 } from 'ohash';

/**
 * Mutable version of `arrayInsert()`.
 * Inserts an element(s) in a certain position of the given array. \
 * Mutates the original array.
 *
 * @param   arr     The original array.
 * @param   index   The needed index of newly added element(s).
 * @param   items   The item or items to insert.
 *
 * @returns         The array itself with inserted elements.
 */
declare const arrayInsertMutable: (arr: any[], index: number, ...items: any[]) => any[];
/**
 * Inserts an element(s) in a certain position of the given array. \
 * Doesn't mutate the original array.
 *
 * @param   arr     The original array.
 * @param   index   The needed index of newly added element(s).
 * @param   items   The item or items to insert.
 *
 * @returns         The whole new array with inserted elements.
 */
declare const arrayInsert: (arr: any[], index: number, ...items: any[]) => any[];

/**
 * Constructs an array of a given length.
 * Kinda syntax sugar for `Array.from({ length: n })`.
 *
 * @param   length        The needed length of array.
 * @param   mapFunction   Optional function to return each element value.
 *
 * @returns               An array of a given length.
 */
declare const arrayOfLength: <T = undefined>(length: number, mapFunction?: ((index: number) => T) | undefined) => T[];

/**
 * Returns an array of integers starting from argument `from` and ending with `to` argument. \
 * Returns an array starting from / ending with `0` if single argument is passed.
 *
 * @param   from   Lower value of resulting array
 * @param   to     Upper value of resulting array
 *
 * @returns        An array starting with `from` and ending with `to`.
 */
declare const arrayRange: (from: number, to?: number) => number[];

/**
 * Mutable version of `arrayRemove()`.
 * Removes an element from a given array. \
 * Doesn't mutate the original array.
 *
 * @param   arr         The original array.
 * @param   value       The value to remove.
 * @param   onlyFirst   Whether to remove only first occurrence or all occurrences found.
 *                      Default is `false` that means to remove all occurrences.
 *
 * @returns             The array itself without specified elements.
 */
declare const arrayRemoveMutable: <T = any>(arr: T[], value: T, onlyFirst?: boolean) => T[];
/**
 * Removes an element from a given array. \
 * Doesn't mutate the original array.
 *
 * @param   arr         The original array.
 * @param   value       The value to remove.
 * @param   onlyFirst   Whether to remove only first occurrence or all occurrences found.
 *                      Default is `false` that means to remove all occurrences.
 *
 * @returns             The whole new array without specified elements.
 */
declare const arrayRemove: <T = any>(arr: T[], value: T, onlyFirst?: boolean) => T[];

/**
 * Returns `size` random elements from the given array.
 *
 * @param   array      The original array.
 * @param   size       The needed length of sample. \
 *                     Default is `1`.
 * @param   oversize   Should the function return more elements than the original array has if `size` is greater than the original array length? \
 *                     Default is `false`.
 * @returns
 */
declare const arraySample: (array: any[], size?: number, oversize?: boolean) => any;

/**
 * Shuffles the given array.
 *
 * @param   array
 *
 * @returns         Shuffled array.
 */
declare const arrayShuffle: <T>(array: readonly T[]) => T[];

/**
 * Removes any duplicated values from given array.
 *
 * @example
 * arrayUnique([1, 2, 3, 4, 1, 2, 3]) -> [1, 2, 3, 4]
 *
 * @param   array
 *
 * @returns         Array without any duplicated values
 */
declare const arrayUnique: <T = any>(array: T[]) => T[];

/**
 * Computes the symmetrical difference of passed arrays.
 *
 * @example
 * arraysDifference([1, 2, 3], [2, 3, 4]) -> [1, 4]
 *
 * @param   arrays   An arrays to process.
 * @returns          An array containing all the unique values of each array.
 */
declare const arraysDifference: <T = any>(...arrays: T[][]) => T[];

/**
 * Computes intersection of passed arrays.
 *
 * @example
 * arraysIntersection([1, 2, 3], [2, 3, 4]) -> [2, 3]
 * arraysIntersection([1, 2, 3], [2, 3, 4], [3, 4, 5]) -> [3]
 *
 * @param   arrays   Arrays to find intersection
 *
 * @returns          Intersection between arrays
 */
declare const arraysIntersection: <T = any>(...arrays: T[][]) => T[];

/**
 * Computes the union of passed arrays.
 *
 * @example
 * arraysUnion([1, 2, 3], [3, 4, 5]) -> [1, 2, 3, 4, 5]
 *
 * @param   arrays   Arrays to process
 *
 * @returns          Union of arrays
 */
declare const arraysUnion: <T = any>(...arrays: T[][]) => T[];

type ToReturn$4<T> = T extends any[] ? T : T[];
/**
 * Casts the given value to an array.
 * Remains array as is if given value is an array already.
 *
 * @param   value   Any value
 *
 * @returns         Array itself if the value is already array, single-value array containing value otherwise
 */
declare const toArray: <T>(value: T) => ToReturn$4<T>;

/**
 * Retrieves count of days in given `month` and `year`. \
 * Uses local time year if no `year` argument is passed.
 *
 * @param   monthIndex   Index of month (January is 0)
 * @param   year         Year (uses local time year if omitted)
 *
 * @returns              Count of days in given month for year `year` (or local year)
 */
declare const daysInMonth: (monthIndex: number, year?: number) => number;

type Axis$4 = 'x' | 'y' | 'both';
type ToReturn$3<T> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the document scroll size (width, height or both).
 *
 * @param   [axis]   Whether to return the document scroll width (x) or height (y), or both.
 *
 * @returns          The document scroll size in defined axis or both.
 */
declare const getDocumentSize: <T extends Axis$4>(axis?: T) => ToReturn$3<T>;

/**
 * Retrieves the Element by a given selector using optional parent element,
 * or just returns a given element as is.
 *
 * @param   value    Queried element selector or the element itself.
 * @param   parent
 *
 * @returns          The element being queried.
 */
declare const getElement: (value: Element | string | null, parent?: Element | string | null) => Element | null;

type Axis$3 = 'x' | 'y' | 'both';
type ToReturn$2<T> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the element offset from given ancestor.
 *
 * @param   el       Element
 * @param   axis     Retrieve only `x` or `y` offset, or both
 * @param   parent   Parent element, default is `window`
 * @returns          The element offset
 */
declare const getElementOffset: <T extends Axis$3>(el: Element, axis?: T, parent?: Element | Window) => ToReturn$2<T>;

type Axis$2 = 'x' | 'y' | 'both';
type ToReturn$1<T> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the maximum scroll value.
 *
 * @param   [axis]   Scroll axis (x | y | both).
 *
 * @returns          The maximum scroll value by a given axis or both (default is 'y').
 */
declare const getScrollLimit: <T extends Axis$2>(axis?: T) => ToReturn$1<T>;

type Axis$1 = 'x' | 'y' | 'both';
/**
 * Retrieves the nearest scrollable ancestor element of a given element.
 *
 * @param   element   The element being evaluated.
 * @param   axis      Consider only one axis (`x`, `y`) or both
 *
 * @returns           The nearest scrollable ancestor element of a given element, or the `window` object.
 */
declare const getScrollableAncestor: (element: Element | null, axis?: Axis$1) => Element | Window;

/**
 * Retrieves scrollbar width of element with body as default.
 *
 * @param   el   Element to retrieve its scrollbar width.
 * @returns      Scrollbar width in `px`.
 */
declare const getScrollbarWidth: (el?: HTMLElement) => number;

type Axis = 'x' | 'y' | 'both';
type ToReturn<T extends Axis> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the window scroll value for given axis, or both
 *
 * @param   axis   Axis to restrict return value
 *
 * @returns        Window scroll for given axis or both (default is 'y')
 */
declare const getWindowScroll: <T extends Axis>(axis?: T) => ToReturn<T>;

/**
 * Checks if the code is running on the client side.
 *
 * @returns   Whether a browser is being used for execution
 */
declare const isClient: () => boolean;

/**
 * Checks whether the application runs in development mode.
 *
 * @returns   Whether the application runs in development node.
 */
declare const isDev: () => boolean | null;

/**
 * Checks if a Firefox browser is being used.
 *
 * @returns   Whether Firefox browser is being used.
 */
declare const isFirefox: () => boolean;

/**
 * Checks if a legacy Internet Explorer browser (IE <= 11) is being used.
 *
 * @returns   Whether legacy IE browser (<= 11) is being used.
 */
declare const isInternetExplorer: () => boolean;

/**
 * Checks if a Lighthouse user agent is being used. \
 * I condemn the use, but it is difficult to explain to customers.
 *
 * @returns   Whether the browser with Lighthouse user agent is being used.
 */
declare const isLighthouse: (userAgent?: string) => boolean;

/**
 * Checks if a mobile browser is being used.
 *
 * @returns   Whether any mobile browser is being used.
 */
declare const isMobile: () => boolean;

/**
 * Checks whether the user has requested the operating system
 * to minimize the amount of animation or motion it uses.
 *
 * @returns   Whether user prefer to reduce motion
 */
declare const isMotionless: () => boolean;

/**
 * Checks if an Apple device is being used.
 *
 * @returns   Whether any Apply device is being used
 */
declare const isOSX: () => boolean;

/**
 * Checks whether the application runs in production mode.
 *
 * @returns   Whether the application runs in production node.
 */
declare const isProd: () => boolean | null;

/**
 * Checks if the code is running on the server side (outside the browser context)
 *
 * @returns   Whether a server environment is being used for execution
 */
declare const isServer: () => boolean;

/**
 * Checks whether the application runs in testing mode.
 *
 * @returns   Whether the application runs in testing node.
 */
declare const isTest: () => boolean;

/**
 * Checks whether the current browser runs on a touch device.
 *
 * @returns   Whether any touch device is being used
 */
declare const isTouch: () => boolean;

/**
 * Checks whether the current browser supports passive event listeners.
 *
 * @returns   Whether the browser supports passive events
 */
declare const supportsPassive: () => boolean;

type Builtin = Primitive | Date | RegExp | Function | Error;

/**
 * Helper utility for exported `ArrayOf` type
 */
type CreateArrayOf<Quantifier extends 'exactly' | 'at least', Count extends number, Type, Current extends Type[]> = Current['length'] extends Count ? Quantifier extends 'exactly' ? [...Current] : [...Current, ...Type[]] : CreateArrayOf<Quantifier, Count, Type, [...Current, Type]>;
/**
 * An array of a given type comprised of either exactly
 * or at least a certain count of that type.
 */
type ArrayOf<Quantifier extends 'exactly' | 'at least', Count extends number, Type = any> = CreateArrayOf<Quantifier, Count, Type, []>;

/**
 * Non empty array
 */
type NonEmptyArray<T = any> = [T, ...T[]];

/**
 * Array, or not yet
 */
type Arrayable<T> = T | T[];

/**
 * Null or whatever
 */
type Nullable<T> = T | null;

/**
 * Sums two numbers.
 */
type MathAdd<A extends number, B extends number> = [
    ...ArrayOf<'exactly', A>,
    ...ArrayOf<'exactly', B>
]['length'];

/**
 * Subtracts two numbers.
 */
type MathSubtract<A extends number, B extends number> = ArrayOf<'exactly', A> extends [...(infer U), ...ArrayOf<'exactly', B>] ? U['length'] : never;

/**
 * Helper utility to construct exported `NumberRange` type.
 */
type CreateNumberRange<Start extends number, End extends number, Result extends unknown[] = [], Length extends number = MathSubtract<End, Start>> = (Result['length'] extends Length ? [...Result, End][number] : CreateNumberRange<Start, End, [...Result, MathAdd<Start, Result['length']>]>);
/**
 * Creates a range of numbers.
 * Limitations: works only with natural numbers (integer >= 0), length of resulting type is also limited to like 600 elements.
 */
type NumberRange<Start extends number, End extends number> = CreateNumberRange<Start, End>;

/**
 * Object keys as an array. \
 * Suitable for typing `Object.keys()`
 */
type ObjectKeys<T extends object> = `${Exclude<keyof T, symbol>}`;

/**
 * Object entries. \
 * Suitable for typing `Object.entries()`
 */
type ObjectEntries<Type extends Record<PropertyKey, any>> = Array<[ObjectKeys<Type>, Type[ObjectKeys<Type>]]>;

/**
 * Object from entries. \
 * Suitable for typing `Object.fromEntries()`
 */
type ObjectFromEntries<Key extends PropertyKey, Entries extends ReadonlyArray<readonly [Key, any]>> = {
    [K in Extract<Entries[number], readonly [Key, any]>[0]]: Extract<Entries[number], readonly [K, any]>[1];
};

/**
 * Object values as an union with optional ability to set which keys should be presented.
 */
type ObjectValues<T extends Record<PropertyKey, any>, K extends keyof T = keyof T> = Array<T[K]>;

/**
 * Just an object.
 */
type PlainObject<T = any> = Record<string, T>;

/**
 * A string ending with another string.
 */
type EndsWith<Affix extends string = ''> = `${string}${Affix}`;

/**
 * A string starting with another string.
 */
type StartsWith<Affix extends string> = `${Affix}${string}`;

/**
 * Removes repeating `Character` from the right side of given `Input`.
 */
type TrimEnd<Input extends string, Character extends string = ' '> = Input extends `${infer R}${Character}` ? TrimEnd<R, Character> : Input;

/**
 * Removes repeating `Character` from the left side of given `Input`
 */
type TrimStart<Input extends string, Character extends string = ' '> = Input extends `${Character}${infer R}` ? TrimStart<R, Character> : Input;

/**
 * Properties that are passed (or executed and then passed) to reporters and Error.
 */
type Properties = JsonObject | (() => JsonObject);
/**
 * Failure type depending on the type of the first argument.
 */
type FailureType = 'condition' | 'no-value';
/**
 * The function that formats an error.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 *
 * @returns               Formatted string message.
 */
type ErrorFormatter = (failureType: FailureType, message?: string, properties?: JsonObject) => string;
/**
 * The function that creates an Error object depending on given arguments.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 *
 * @returns               Error instance to be thrown.
 */
type ErrorCreator = (failureType: FailureType, message?: string, properties?: JsonObject) => Error;
/**
 * The function that executes user-defined logic
 * depending on the given arguments before Error is thrown.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 */
type ErrorReporter = (failureType: FailureType, error: Error, message?: string, properties?: JsonObject) => void;
/**
 * The function that executes user-defined logic depending on the given arguments
 * using `.soft()` version of `assert` if it fails.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 */
type WarningReporter = (failureType: FailureType, message?: string, properties?: JsonObject) => void;
/**
 * Configuration of `assert` method.
 */
type AssertConfiguration = {
    formatter?: ErrorFormatter;
    errorCreator?: ErrorCreator;
    errorReporter?: ErrorReporter;
    warningReporter?: WarningReporter;
};
interface HardAssert {
    /**
     * Verifies that the condition is satisfied.
     *
     * @param   condition    Condition to be true.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @throws Throws exception if condition is `false`.
     */
    (condition: boolean, message?: string, properties?: Properties): asserts condition;
    /**
     * Verifies that the given value is not `null` or `undefined`.
     *
     * @param   value        Value to be verified.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @throws Throws exception if value is `null` or `undefined`.
     */
    <T>(value: T | boolean | undefined | null, message?: string, properties?: Properties): asserts value is T;
}
interface SoftAssert {
    /**
     * Test if the condition is satisfied. \
     * If `false`, a warning will be reported.
     *
     * @param   condition    Condition to be `true`.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @returns              Boolean representing condition.
     */
    (condition: boolean, message?: string, properties?: Properties): condition is true;
    /**
     * Test if the given value is not `null` or `undefined`. \
     * If value is `null` or `undefined`, a warning will be reported.
     *
     * @param   value        Value to test.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @throws Throws exception if value is `null` or `undefined`.
     */
    <T>(value: T | boolean | undefined | null, message?: string, properties?: Properties): value is T;
}
interface Assert extends HardAssert {
    /**
     * The version of `assert` utility that doesn't throw an Error.
     */
    soft: SoftAssert;
}

declare const assert: Assert;
/**
 * The function that allows to redeclare one or many configuration options.
 *
 * @param   customConfiguration   The custom configuration to use.
 */
declare const configureAssert: (customConfiguration: AssertConfiguration) => void;

/**
 * A very simple alternative of `pipeline operator` working with single return value
 *
 * @see https://github.com/tc39/proposal-pipeline-operator
 *
 * @example
 * const func1 = (v) => v + '-baz';
 * const func2 = (v) => v + '-bar';
 *
 * compose(func1, func2)('foo') -> func1(func2('foo')) -> 'foo-bar-baz'
 *
 * @param   functions   Functions to proccess value with.
 *
 * @returns             Composed function
 */
declare const compose: (...functions: readonly Function[]) => any;

/**
 * Delays a given function invoking until a given `delay` time have elapsed since the last time a function was invoked.
 *
 * @param   fn          A function being invoked.
 * @param   delay       Timeout between function invoking, ms.
 * @param   immediate   Whether to invoke a given function immediately after initialization.
 *
 * @returns             Debounced function
 */
declare const debounce: <F extends (...args: any[]) => any>(fn: F, delay?: number, immediate?: boolean) => (...args: Parameters<F>) => ReturnType<F>;

type HashOptions = Parameters<typeof hash$1>[1];
/**
 * Hashes any JS value into a string.
 *
 * @param   value     The value to hash.
 * @param   options   Hashing options.
 * @returns           Hash string for a given value.
 */
declare const hash: (value: any, options?: HashOptions) => string;

/**
 * Does nothing.
 *
 * @returns   {void}   Nothing
 */
declare const noop: Function;

/**
 * Exposes a simple way to make the delay via Promise.
 *
 * @param   duration   Duration of delay (ms)
 *
 * @returns            Nothing.
 */
declare const sleep: (duration?: number) => Promise<void>;

type Options$3 = {
    delay: number;
    leading?: boolean;
    trailing?: boolean;
};
declare const throttle: (callback: Function, optionsOrDelay?: Options$3 | number) => {
    (...args: any[]): void;
    cancel: () => void;
};

/**
 * Checks whether a given value is an array.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Array
 */
declare const isArray: <T = any>(value: any) => value is T[];

/**
 * Checks whether a given value is a boolean.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Boolean
 */
declare const isBoolean: (value: any) => value is boolean;

/**
 * Checks whether a given value is a date object.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Date object
 */
declare const isDate: (value: any) => value is Date;

/**
 * Checks whether a given value is a DOM Element.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is DOM Element
 */
declare const isElement: (value: any) => value is Element;

/**
 * Checks whether a given string is a valid email.
 *
 * @param   str   The value being evaluated.
 *
 * @returns       Whether the value is a valid email address
 */
declare const isEmail: (str: string) => boolean;

declare const isEmpty: (value: any) => boolean;

/**
 * Checks whether a given value is a float number.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is float number
 */
declare const isFloat: (value: any) => boolean;

/**
 * Checks whether a given value is a FormData object.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is FormData instance
 */
declare const isFormData: (value: any) => boolean;

/**
 * Checks whether a given value is a function.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Function
 */
declare const isFunction: (value: any) => value is Function;

/**
 * Checks whether a given value is an integer number.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is integer number
 */
declare const isInteger: (value: any) => value is number;

/**
 * Checks whether a given value is iterable.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is `Iterable`.
 */
declare const isIterable: (value: any) => value is Iterable<any>;

/**
 * Checks whether the given value is a Map.
 * Note: this might not work when performed in a different window context.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the given value is a Map or not.
 */
declare const isMap: (value: any) => value is Map<any, any>;

/**
 * Checks whether a given value is a Node.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a Node
 */
declare const isNode: (value: any) => value is Node;

/**
 * Checks whether a given value is considered to be nullish.
 *
 * @see      https://developer.mozilla.org/en-US/docs/Glossary/Nullish
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is nullish value
 */
type NullishType = null | undefined;
declare const isNullish: (value: any) => value is NullishType;

/**
 * Checks whether a given value is a valid number.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a valid number
 */
declare const isNumeric: (value: any) => value is number;

/**
 * Checks whether a given value is an object.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Object
 */
declare const isObject: (value: any) => value is Record<string, any>;

/**
 * Checks whether the value is a primitive.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a primitive value.
 *
 * @see https://developer.mozilla.org/en-US/docs/Glossary/Primitive
 */
declare const isPrimitive: (value: any) => value is Primitive;

/**
 * Checks whether a given value is a Promise.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Promise
 */
declare const isPromise: (value: any) => value is Promise<any>;

/**
 * Checks whether a given value is an instance of RegExp.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is RegExp
 */
declare const isRegExp: (value: any) => value is RegExp;

/**
 * Checks whether a given value is a string.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is String
 */
declare const isString: (value: any) => value is string;

/**
 * Checks whether a given value is a symbol.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is symbol.
 */
declare const isSymbol: (value: any) => value is symbol;

/**
 * Checks whether the given value is a WeakMap.
 * Note: this might not work when performed in a different window context.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the given value is a WeakMap or not.
 */
declare const isWeakMap: (value: any) => value is WeakMap<any, any>;

/**
 * Clamps a value between an upper and lower bound.
 *
 * @param   value   The preferred value to return.
 * @param   min     The lowest value to return or `null` to skip.
 * @param   max     The highest value to return or `null` to skip.
 *
 * @returns         Value not less than the `min` and not greater than the `max`
 */
declare const clamp: (value: number, min?: number | null, max?: number | null) => number;

type Prefix = 'b' | 'k' | 'm' | 'g' | 't' | 'p' | 'e' | 'z' | 'y';
type Mode = 'metric' | 'IEC';
type Options$2 = {
    /**
     * The needed precision of the return value.
     *
     * @default 1
     */
    precision: number;
    /**
     * The first character of unit for return value or keyword `auto`. \
     * 'k' means 'kB' or 'KiB', 'm' means 'mB' or 'MiB' and so on.
     *
     * @default 'auto'
     */
    to: 'auto' | Prefix;
    /**
     * The base to calculate a value.
     * `metric` uses powers of ten, `IEC` uses powers of two.
     *
     * @default 'metric'
     */
    mode: Mode;
    /**
     * Whether to trim trailing zeros for the value (in a string form)
     */
    trimZeros: boolean;
    /**
     * An overrides for default  units, will be merged with it. \
     * Useful for translations.
     */
    customUnits: {
        [key in Mode]?: Partial<{
            [innerKey in Prefix]: string;
        }>;
    };
    /**
     * Custom formatter for `asString` property of return value, also overrides `.toString` method of object itself.
     *
     * @param   value           Calculated value as number
     * @param   valueAsString   Calculated value as string
     * @param   unit            Calculated unit name
     * @param   isInteger       Whether the calculated value is integer number. Mostly used for `i18n` purposes.
     *
     * @returns                 String representation of return value
     */
    toString: (value: number, valueAsString: string, unit: string, isInteger: boolean) => string;
};
declare class FormatBytes {
    /**
     * The calculated value.
     */
    value: number;
    /**
     * The calculated value in string form with needed precision.
     */
    valueAsString: string;
    /**
     * Calculated unit of value.
     */
    unit: string;
    /**
     * Whether the value is an integer number. \
     * Mostly used for `i18n` purposes.
     */
    isInteger: boolean;
    constructor(bytes: number, customOptions?: Partial<Options$2>);
    toString(): any;
}
declare const formatBytes: (bytes: number, customOptions?: Partial<Options$2>) => FormatBytes;
declare const formatBytesRu: (bytes: number, _customOptions?: Partial<Options$2>) => FormatBytes;

/**
 * Formats a given number with grouped thousands.
 *
 * @param   numberOrStringRepresentingNumber   The number being formatted.
 * @param   decimals                           The number of decimal points. Default 0.
 * @param   fractionSeparator                  The separator for the decimal point. Default `.`.
 * @param   thousandsSeparator                 The thousands separator. Default ` `.
 *
 * @returns                                    Formatted number.
 */
declare const numberFormat: (numberOrStringRepresentingNumber: any, decimals?: number, fractionSeparator?: string, thousandsSeparator?: string) => string;

/**
 * Generates a random float with given `precision` (including `min` and `max` values).
 *
 * @param   min         The lowest value to return.
 * @param   max         The highest value to return.
 * @param   precision   The needed precision of return value.
 *
 * @returns             The random value between specified min and max values with given precision.
 */
declare const randomFloat: (min: number, max: number, precision?: number) => number;

/**
 * Generates a random integer (including `min` and `max` values). \
 * Returns a random integer between 1 and `MAX_SAFE_INTEGER`
 * if called with no arguments which covers the most frequent use case.
 *
 * @param   min   The lowest value to return.
 * @param   max   The highest value to return.
 *
 * @returns       Random integer value greater than `min` and less than `max` (inclusive)
 */
declare const randomInteger: (min?: number, max?: number) => number;

/**
 * Attempts to cast the passed value to a number.
 * If the cast was successful, returns resulting number.
 * If the cast was unsuccessful, throws an Error unless the fallback value is provided.
 *
 * @param   value      The value to cast.
 * @param   fallback   Fallback value if cast was unsuccessful.
 *
 * @returns            The number if cast was successful, fallback value otherwise if provided.
 * @throws               Throws if cast was unsuccessful with no fallback value provided.
 */
declare function toNumber<F = undefined>(value: any, fallback?: F): number | F;

/**
 * Copies a value deeply.
 *
 * @see https://github.com/planttheidea/fast-copy#copy
 *
 * @param   value   The value being processed.
 *
 * @returns         The structured clone of a given value.
 */
declare const deepClone: <T>(value: T) => T;
/**
 * Copies a value deeply considering property descriptors,
 * non-enumerable keys and any non-standard extensions.
 *
 * @see https://github.com/planttheidea/fast-copy#copystrict
 *
 * @param   value   The value being processed.
 *
 * @returns         The structured clone of a given value.
 */
declare const deepCloneStrict: <T>(value: T) => T;

/**
 * Checks if of two objects are the same data (deep equality).
 * There is no support for circular objects.
 *
 * @param   a   The value to compare #1.
 * @param   b   The value to compare #2.
 * @returns     Result of comparing two given values (deep equality).
 */
declare const deepEqual: (a: unknown, b: unknown) => boolean;
/**
 * Checks if of two objects are the same data (deep equality).
 * This version handles circular objects correctly.
 *
 * @param   a   The value to compare #1.
 * @param   b   The value to compare #2.
 * @returns     Result of comparing two given values (deep equality).
 */
declare const deepEqualCircular: (a: unknown, b: unknown) => boolean;

type Entry = FormDataEntryValue | FormDataEntryValue[];
/**
 * Converts given `FormData` object to plain object.
 *
 * @param   formData   The value being evaluated.
 *
 * @returns            Plain object builded from given FormData.
 */
declare const formDataToObject: (formData: FormData) => Record<string, Entry>;

type MergeObjects<Source extends PlainObject, Input extends PlainObject> = Input extends Source ? Input : (Omit<Source, keyof Source & keyof Input> & Omit<Input, keyof Source & keyof Input> & {
    -readonly [Key in keyof Source & keyof Input]: Input[Key];
});
type MergerFn = <Source extends PlainObject, Input extends PlainObject>(defaults: Source, ...input: Array<Input | null | undefined>) => MergeObjects<Source, Input>;
type Merger = <T extends PlainObject, K extends keyof T>(obj: T, key: keyof T, value: T[K], stack: string) => boolean | undefined;
/**
 * Creates defaults function with custom merger.
 *
 * @param   merger   Custom merger function
 *
 * @returns          Defaults function with custom merger applied.
 */
declare const createMergeObjects: (merger?: Merger) => MergerFn;
/**
 * Mixes properties from source into target when
 *
 * @param   defaults   Source object
 * @param   ...input   Custom object(s) to be merged with source or result of previous merge
 *
 * @returns            Merged object.
 */
declare const mergeObjects: MergerFn;

type PathVariant = string | Array<string | number>;
/**
 * Gets a property from an object using dot (object path) notation.
 *
 * @param   input          The value to search in.
 * @param   path           The path to search using dot or array notation.
 * @param   defaultValue   The value to return if the path doesn't exist.
 * @returns                The value of property in the passed path if exists, `defaultValue` otherwise.
 */
declare const objectGet: (input: any, path: PathVariant, defaultValue?: any) => any;

type Case = 'snake_case' | 'PascalCase' | 'kebab-case' | 'camelCase';
type Options$1 = {
    depth: number;
    exclude: Array<string | RegExp>;
    excludeBranches: Array<string | RegExp>;
};
/**
 * Creates a new object from given one with the keys written in needed case.
 *
 * @param   input        Object to convert keys case.
 * @param   neededCase   Needed keys case.
 * @param   _options     Custom options.
 *
 * @returns              New object with keys "renamed" to needed case.
 */
declare const objectKeysCase: (input: any, neededCase: Case, _options?: Partial<Options$1>) => any;

/**
 * Removes the specified keys from the given object and returns new object.
 *
 * @param   obj    Original object.
 * @param   keys   Keys of original object to remove.
 *
 * @returns        New object without specified keys
 */
declare const omit: <T, K extends keyof T>(obj: T, ...keys: K[]) => Omit<T, K>;

/**
 * Returns the new object containing only the specified keys.
 *
 * @param   obj    Original object.
 * @param   keys   Keys of original object to pick.
 *
 * @returns        New object containing only the specified keys.
 */
declare const pick: <T extends PlainObject, K extends keyof T>(obj: T, ...keys: K[]) => Pick<T, K>;

/**
 * Object containing typed versions of popular `Object` methods.
 */
declare const tsObject: {
    /**
     * Typed version of `Object.keys()`.
     *
     * @param   obj   Object to process.
     *
     * @returns       `Object.keys()` return value for a given object.
     */
    keys: <T extends PlainObject>(obj: T) => `${Exclude<keyof T, symbol>}`[];
    /**
     * Typed version of `Object.values()`.
     *
     * @param   obj   Object to process.
     *
     * @returns       `Object.values()` return value for a given object.
     */
    values: <T_1 extends PlainObject>(obj: T_1) => ObjectValues<Required<T_1>>;
    /**
     * Typed version of `Object.entries()`.
     *
     * @param   obj   Object to process.
     *
     * @returns       `Object.entries()` return value for a given object.
     */
    entries: <T_2 extends PlainObject>(obj: T_2) => ObjectEntries<Required<T_2>>;
    /**
     * Typed version of `Object.fromEntries()`.
     *
     * @param   entries   Entries to process.
     *
     * @returns           `Object.fromEntries()` return value for a given object.
     */
    fromEntries: <Key extends PropertyKey, Entries extends readonly (readonly [Key, any])[]>(entries: Entries) => ObjectFromEntries<Key, Entries>;
};

/**
 * A wrapper for a promise, guaranteeing that it will not be fulfilled before `minTime` milliseconds.
 * Most often used for better UX, preventing the loader from flickering for 30-100ms, which looks weird.
 *
 * @param   promise   A promise for which you need to provide a minimum amount of time.
 * @param   minTime   Minimum time in which the result will be obtained.
 *
 * @returns           The result of fulfilling a given promise.
 */
declare const minTimePromise: <T>(promise: Promise<T>, minTime?: number) => Promise<any>;

type PromiseController<T = undefined> = Promise<T> & {
    resolve: (value?: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
};
/**
 * Returns a Promise with `resolve` and `reject` methods itself
 *
 * @returns   Promise with extra `resolve` and `reject` methods
 */
declare const promiseController: <T>() => PromiseController<T>;

type Range = readonly [number | null | undefined, number | null | undefined];
type OutputRange = [number | null, number | null];

/**
 * Checks whether at least one of provided ranges
 * (or all of them depending on the `mode` argument) includes a given number.
 *
 * @param   value    The number to search in ranges.
 * @param   ranges   The ranges to check for occurrences.
 * @param   mode     Whether the every range includes a number (`all`) or at least one is enough (`any`). Default is `any`.
 *
 * @returns          Is any range (or all of them depending on the `mode` argument) includes a given number.
 */
declare const rangeIncludes: (value: number, ranges: Range[] | null | undefined, mode?: 'all' | 'any') => boolean;

/**
 * Crops an array of ranges if they go beyond the `start` and `end`.
 *
 * @param   ranges           An array of ranges to crop.
 * @param   start            Minimum allowed range value.
 * @param   end              Maximum allowed range value.
 * @param   infinityToNull   Whether the return value should be `null` instead of `+-Infinity`.
 *
 * @returns                  The array of cropped ranges.
 */
declare const rangesCrop: (ranges: Range[] | null | undefined, start?: number | null, end?: number | null, infinityToNull?: boolean) => OutputRange[];

declare const rangesInvert: (ranges: Array<Range | null> | null | undefined, start?: number | null, end?: number | null, infinityToNull?: boolean) => OutputRange[];

/**
 * Sorts and merges given ranges.
 *
 * @param   ranges      An array of ranges.
 * @param   joinEdges   Whether to combine ranges if they are contiguous.
 *
 * @returns             Sorted and merged ranges or an empty array for invalid input.
 */
declare const rangesMerge: (ranges: Array<Range | null> | null | undefined, joinEdges?: boolean) => OutputRange[];

/**
 * Sorts given ranges.
 *
 * @param   ranges   An array of ranges.
 *
 * @returns          Sorted ranges or an empty array for invalid input.
 */
declare const rangesSort: (ranges: Array<Range | null> | null | undefined) => Range[];

type CamelCaseOptions = {
    readonly preserveConsecutiveUppercase?: boolean;
};
/**
 * Converts a dash/dot/underscore/space separated string to camelCase: `foo-bar` → `fooBar`
 *
 * @param        input     A string/array of strings to convert to camelCase.
 * @param        options   Additional options being supplied to the `_camelCase`.
 *
 * @returns                The string converted to camelCase.
 * @throws    {TypeError}  Throws if not string is passed
 */
declare const camelCase: (input: string | readonly string[], options?: CamelCaseOptions) => string;

/**
 * Converts the first character of string to upper case.
 *
 * @param   input   The string to capitalize.
 *
 * @returns         Capitalized string.
 */
declare const capitalize: (input: string) => string;

/**
 * Escapes the `RegExp` special characters in a given string.
 *
 * @param   str   The string to escape.
 *
 * @returns       The escaped string.
 */
declare const escapeRegExp: (str: string | null | undefined) => string;

/**
 * Returns the file extension for given filename / filepath.
 *
 * @param   input   Filename / Full path to file
 *
 * @returns         File extension (without leading dot) or `null`
 */
declare const fileExtension: (input: string) => string | null;

type FormatSlashesOptions = {
    /**
     * Slash variant
     */
    to: '/' | '\\';
    /**
     * Should there be a leading slash?
     */
    start: boolean;
    /**
     * Should there be a trailing slash?
     */
    end: boolean;
};
/**
 * Formats given string
 *
 * @param   input     The input string.
 * @param   options   Formatter options.
 *
 * @returns           Formatted string.
 */
declare const formatSlashes: (input: string, options?: Partial<FormatSlashesOptions>) => string;

type Options = {
    /**
     * Whether numbers should be separated.
     */
    numbers: boolean;
};
/**
 * Convert a string to kebab-case: `fooFar` → `foo-bar`
 *
 * @param   input      A string to convert to kebab-case
 *
 * @param   _options   Transform options
 * @returns            The string converted to kebab-case.
 */
declare const kebabCase: (input: string, _options?: Options) => string;

/**
 * Pads the given number/string with a given `fillString` (repeated, if needed) so that the resulting string reaches a given length.
 * The padding is applied from the end of the given string.
 *
 * @param   input        String / number to apply pad.
 * @param   maxLength    The length of the resulting string once the given string has been padded.
 * @param   fillString   The string to pad the given string with.
 *
 * @returns              The padded string.
 */
declare const padEnd: (input: string | number, maxLength: number, fillString?: string) => string;

/**
 * Pads the given number/string with a given `fillString` (repeated, if needed) so that the resulting string reaches a given length.
 * The padding is applied from the start of the given string.
 * `maxLength` and `fillString` defaults cover the most popular use case - leading zero to length 2.
 *
 * @param   input        String / number to apply pad.
 * @param   maxLength    The length of the resulting string once the given string has been padded.
 * @param   fillString   The string to pad the given string with.
 *
 * @returns              The padded string.
 */
declare const padStart: (input: string | number, maxLength?: number, fillString?: string) => string;

type PascalCaseOptions = {
    readonly preserveConsecutiveUppercase?: boolean;
};
/**
 * Convert a dash/dot/underscore/space separated string to PascalCase: `foo-bar` → `FooBar`
 *
 * @param   input     A string/array of strings to convert to PascalCase.
 * @param   options   Additional options being supplied to the `_camelCase`.
 *
 * @returns           The string converted to PascalCase.
 */
declare const pascalCase: (input: string | readonly string[], options?: PascalCaseOptions) => string;

/**
 * Quotes the given string with specified `char`.
 *
 * @param   str    String to be quoted.
 * @param   char   Quote character.
 *
 * @returns        Quoted string.
 */
declare const quote: (str: string, char?: string) => string;

/**
 * Generates a random string of a given length and (optionally) starting with a latin character
 * (if used to fill `id` of HTMLElement for example)
 *
 * @param   length           The length of result string. \
 *                           Default is `10`.
 * @param   startWithLatin   Should string strictly start with latin character or not. \
 *                           Default is `true`.
 *
 * @returns                  Generated string of a given length.
 */
declare const randomString: (length?: number, startWithLatin?: boolean) => string;

/**
 * Retrieves Roman representation of given integer number.
 *
 * @param   num   Integer value to transform to Roman notation
 *
 * @returns       Roman representation of given number
 */
declare const romanize: (num: number) => string;

/**
 * Convert a string to snake-case: `fooFar` → `foo_bar`
 *
 * @param   input   A string to convert to snake-case
 *
 * @returns         The string converted to snake-case.
 */
declare const snakeCase: (input: string) => string;

/**
 * Unquotes the given string.
 *
 * @param   str   String to unquote.
 *
 * @returns       String without start/end quotes/backticks.
 */
declare const unquote: (str: string) => string;

export { ArrayOf, Arrayable, Builtin, EndsWith, MathAdd, MathSubtract, NonEmptyArray, Nullable, NumberRange, ObjectEntries, ObjectFromEntries, ObjectKeys, ObjectValues, PlainObject, StartsWith, TrimEnd, TrimStart, arrayInsert, arrayInsertMutable, arrayOfLength, arrayRange, arrayRemove, arrayRemoveMutable, arraySample, arrayShuffle, arrayUnique, arraysDifference, arraysIntersection, arraysUnion, assert, camelCase, capitalize, clamp, compose, configureAssert, createMergeObjects, daysInMonth, debounce, deepClone, deepCloneStrict, deepEqual, deepEqualCircular, escapeRegExp, fileExtension, formDataToObject, formatBytes, formatBytesRu, formatSlashes, getDocumentSize, getElement, getElementOffset, getScrollLimit, getScrollableAncestor, getScrollbarWidth, getWindowScroll, hash, isArray, isBoolean, isClient, isDate, isDev, isElement, isEmail, isEmpty, isFirefox, isFloat, isFormData, isFunction, isInteger, isInternetExplorer, isIterable, isLighthouse, isMap, isMobile, isMotionless, isNode, isNullish, isNumeric, isOSX, isObject, isPrimitive, isProd, isPromise, isRegExp, isServer, isString, isSymbol, isTest, isTouch, isWeakMap, kebabCase, mergeObjects, minTimePromise, noop, numberFormat, objectGet, objectKeysCase, omit, padEnd, padStart, pascalCase, pick, promiseController, quote, randomFloat, randomInteger, randomString, rangeIncludes, rangesCrop, rangesInvert, rangesMerge, rangesSort, romanize, sleep, snakeCase, supportsPassive, throttle, toArray, toNumber, tsObject, unquote };
